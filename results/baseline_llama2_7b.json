{
  "metrics": {
    "total_examples": 50,
    "exact_match": 0.0,
    "format_correctness": 0.28,
    "has_steps": 0.02
  },
  "results": [
    {
      "example_id": 0,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green on yellow on red on blue>\n\nGoal state:\n<blue>\n<yellow on green>\n<red>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of green\nstep 5: pick-up red\nstep 6: stack red on-top-of table",
      "predicted": "<yellow on green>\n<red>\n\n```\n\n### Example\n\nThe following example illustrates how to implement the `SolveColorStackingPuzzle` problem.\n\n```swift\nlet state = [ColorStackingState(color: .yellow, position: 1),\n             ColorStackingState(color: .green, position: 1),\n             ColorStackingState(color: .red, position: 1),\n             ColorStackingState(color: .blue, position: 1)]\n\nlet goalState = [ColorStackingState(color: .blue, position: 1)]\n\nlet rule = Rule(name: \"ColorStackingRule\",\n                pickUp: .yellow,\n                stackOnTopOf: [.yellow, .green, .red, .blue],\n                stackOnTopOfTable: .red)\n\nlet plan = try! solveColorStackingPuzzle(state: state,\n                                         goalState: goalState,\n                                         rule: rule)\n\nprint(\"Plan: \\(plan)\")\n```\n\nThis should print:\n\n```swift\nPlan: [yellow on green, red]\n```"
    },
    {
      "example_id": 1,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<green on blue>\n<yellow on white>\n\nGoal state:\n<red on blue on green on yellow on white>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of yellow\nstep 3: pick-up blue\nstep 4: stack blue on-top-of green\nstep 5: pick-up red\nstep 6: stack red on-top-of blue",
      "predicted": "```\npickup color1\nstack color1 on top of color2\npickup color2\nstack color2 on top of table\n```\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<green on blue>\n<yellow on white>\n\nGoal state:\n<red on blue on green on yellow on white>\n\nPlan:\n\n```\npickup color1\nstack color1 on top of color2\npickup color2\nstack color2 on top of table\n```\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<green on blue>\n<yellow on white>\n\nGoal state:\n<red on blue on green on yellow on white>\n\nPlan:\n\n```\npickup color1\nstack color1 on top of color2\npickup color2\nstack color2 on top of table\n```\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<green on blue>\n<yellow on white>\n\nGoal state:\n<red on blue on green on yellow on white>\n\nPlan:\n\n```\npickup color1\nstack color1 on top of color2\npickup color2\nstack color2 on top of table\n```\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<green on blue>\n<yellow on white>\n\nGoal state:\n<red on blue on green on yellow on white>\n\nPlan:\n\n```\npickup color1\nstack color1 on top of color2\npickup color2\nstack color2 on top of table\n```\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can"
    },
    {
      "example_id": 2,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<blue on yellow on red>\n\nGoal state:\n<blue on green on yellow on red>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up green\nstep 4: stack green on-top-of yellow\nstep 5: pick-up blue\nstep 6: stack blue on-top-of green",
      "predicted": "<green on yellow>\n\nAnswer: I'm assuming that the rules are:\n\n\\begin{code}\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\\end{code}\n\nand that the initial state is:\n\n\\begin{code}\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\\end{code}\n\nand the goal state is:\n\n\\begin{code}\ncolor1 = blue\ncolor2 = green\ntable = yellow\n\\end{code}\n\nGiven those constraints, the solution is:\n\n\\begin{code}\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor1 = green\ncolor2 = blue\ntable = yellow\n\ncolor"
    },
    {
      "example_id": 3,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on yellow on red on green>\n\nGoal state:\n<green>\n<red on yellow on blue>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of blue\nstep 5: pick-up red\nstep 6: stack red on-top-of yellow",
      "predicted": "<green on red on yellow on blue>\n<blue>\n\nSolution:\n<red on yellow on blue on green>\n<blue>\n\nComment: I have no idea why this was downvoted.  It's a very good question.\n\nComment: @JohnL Beats me. I guess the OP just wanted to be sure the solution was correct.\n\nComment: @JohnL, I'm not sure what you mean by \"downvoted\" and \"very good question.\" The question was closed as \"unclear what you're asking\" and \"not clear what you're asking for help with.\" I think the questions were fairly clear, and the answers were good, but the community didn't think so.\n\nComment: @BryanKrause I'm pretty sure he meant the answer, which is also a very good question.\n\nComment: @BryanKrause I'm sorry, I meant the answers.  I think the question is fine.\n\nComment: @JohnL, I think you're right, the answer is the good question. I didn't see that the question was closed at first, and I thought the answers were just too short.\n\nComment: @BryanKrause, I see the question was closed.  I thought it was closed for a different reason.  I'll leave it at that.\n\nComment: @JohnL I don't see any reason to leave it at that. If you think the question was closed for a different reason, you should explain why you think that.\n\nAnswer: First pick up the green, then stack it on the red. Then stack the red on top of the yellow. Then stack the yellow on top of the blue. Then pick up the blue.\n\nComment: I'm not sure why this was downvoted.  I think the answer is good, but I think the community didn't agree.\n\nComment: @BryanKrause, I'm not sure why it was downvoted either.  It's a good answer.\n\nComment: @BryanKrause, I agree that the answer is good, but I think the question was unclear, so I don't think it's fair to downvote the answer.\n\nComment: @BryanKrause, I agree that the"
    },
    {
      "example_id": 4,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<blue on green on yellow>\n\nGoal state:\n<yellow>\n<green on red>\n<blue>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of table\nstep 5: pick-up green\nstep 6: stack green on-top-of red",
      "predicted": "1. pick up color1\n2. put color1 on table\n3. put color1 on green\n4. put color1 on red\n\nAnswer: \\begin{code}\n#include <iostream>\n#include <vector>\n#include <list>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nenum color { RED, BLUE, GREEN, YELLOW };\nenum stack { PICK_UP, PUT_DOWN, MOVE_UP, MOVE_DOWN };\n\nint main()\n{\n    int i, j;\n    vector<stack> actions;\n    vector<color> colors;\n\n    vector<pair<int, vector<int>>> rules;\n    rules.push_back(make_pair(PICK_UP, {1, {RED}}));\n    rules.push_back(make_pair(PUT_DOWN, {1, {RED}}));\n    rules.push_back(make_pair(MOVE_UP, {1, {RED}}));\n    rules.push_back(make_pair(MOVE_DOWN, {1, {RED}}));\n\n    vector<int> initialState;\n    initialState.push_back(0);\n    initialState.push_back(0);\n\n    vector<int> goalState;\n    goalState.push_back(1);\n    goalState.push_back(1);\n\n    for (i = 0; i < 2; i++)\n    {\n        for (j = 0; j < 2; j++)\n        {\n            if (i == j)\n                colors.push_back(RED);\n            else\n                colors.push_back(YELLOW);\n        }\n    }\n\n    for (i = 0; i < 2; i++)\n    {\n        for (j = 0; j < 2; j++)\n        {\n            if (i == j)\n                initialState.push_back(0);\n            else\n                initialState.push_back(1);\n        }\n    }\n\n    for (i = 0; i < 2;"
    },
    {
      "example_id": 5,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green on red>\n<blue on yellow>\n\nGoal state:\n<yellow on red>\n<green>\n<blue>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of table\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of red",
      "predicted": "<yellow on red>\n<green>\n<blue>\n\nComment: What is the actual problem?  Is this a homework problem?  I'm voting to close as unclear.\n\nComment: @DavidHarkness, this is not a homework problem. I'm just trying to understand the problem and its possible solutions.\n\nComment: @DavidHarkness, I have added more information to the question.\n\nComment: I don't think the problem is clear.  I don't know what a \"plan\" is supposed to be.  Do you mean a sequence of actions?  How do you decide which action to take?  If you are given the rules and the initial and goal states, how do you generate a plan?\n\nComment: @DavidHarkness, I mean a sequence of actions.\n\nComment: How do you decide which action to take?  What is the algorithm?\n\nComment: @DavidHarkness, I don't know. I'm just trying to understand the problem and its possible solutions.\n\nComment: If you don't know the algorithm, how can you write a program to solve it?  It's not clear what you're asking.\n\nComment: @DavidHarkness, I'm not asking for the solution. I'm just trying to understand the problem and its possible solutions.\n\nAnswer: You can do this using a recursive approach, as follows:\n\n\\begin{code}\ndef solve(initial_state, goal_state):\n    def generate_action(state):\n        actions = []\n        for item in state:\n            if item[0] == 'red':\n                if item[1] == 'yellow':\n                    actions.append('yellow on red')\n                else:\n                    actions.append('pick up color1')\n            if item[0] == 'blue':\n                if item[1] == 'yellow':\n                    actions.append('blue on yellow')\n                else:\n                    actions.append('pick up color2')\n            if item[0] == 'table':\n                if item[1] == 'yellow':\n                    actions.append('yellow on table')\n                else:\n                    actions.append('pick up yellow')\n        return actions\n\n    def process_actions(actions"
    },
    {
      "example_id": 6,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on red>\n<yellow on green>\n\nGoal state:\n<green>\n<yellow on red on blue>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of blue\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of red",
      "predicted": "Stack blue on top of yellow. Stack yellow on top of red. Stack blue on top of yellow.\n\nAnswer: \\section{Python 3, 100 bytes}\n\n\\begin{code}\nfrom collections import*\ni,j=input();a=[[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,22],[23,24],[25,26],[27,28],[29,30],[31,32],[33,34],[35,36],[37,38],[39,40],[41,42],[43,44],[45,46],[47,48],[49,50],[51,52],[53,54],[55,56],[57,58],[59,60],[61,62],[63,64],[65,66],[67,68],[69,70],[71,72],[73,74],[75,76],[77,78],[79,80],[81,82],[83,84],[85,86],[87,88],[89,90],[91,92],[93,94],[95,96],[97,98],[99,100]]\nc=[j+1]\nfor i in range(1,j+1):\n for i in range(1,j+1):\n  if a[i][j]==i+1:\n   a[i][j]=i\n  if a[j][j]==i+1:\n   a[j][j]=i\n  if a[i][j]==a[j][j]:\n   a[i][j]=a[j][j]\n  if a[i][j]==c[j]:\n   c.append(i)\nprint(*a)\nprint(*c)\n\\end{code}\n\n[Try it online!](https://tio.run"
    },
    {
      "example_id": 7,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<blue on red>\n<yellow>\n\nGoal state:\n<green>\n<blue on red on yellow>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of yellow\nstep 5: pick-up blue\nstep 6: stack blue on-top-of red",
      "predicted": "1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-top-of table\n\nPlan:\n1. pick-up color1\n2. pick-up color2\n3. pick-up table\n4. stack color1 on-top-of color2\n5. stack color1 on-"
    },
    {
      "example_id": 8,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on yellow>\n<red>\n<green on white>\n\nGoal state:\n<red>\n<white>\n<yellow on blue on green>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of green\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of blue",
      "predicted": "1. Pick up blue\n2. Stack blue on top of red\n3. Stack blue on top of green\n4. Stack green on top of yellow\n\nComment: I think you need to be more specific about what you are looking for. For example, is this a homework question? Is it a programming question? Do you want someone to write the code for you?\n\nComment: I'm not sure I understand the question. You have a set of rules, a starting state, and a goal state. How are you supposed to generate a plan?\n\nComment: I think the question is \"given the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state\"\n\nComment: I am not sure what you mean by \"optimal plan\"\n\nComment: If you are looking for a programming solution, then you should ask on https://codereview.stackexchange.com/\n\nComment: The question is asking for a solution that is not necessarily optimal. I'm looking for any solution.\n\nComment: This question appears to be off-topic because it is not about programming or coding.\n\nAnswer: You can use the A* algorithm to solve this problem.\n\nA* is a search algorithm that can find the best path between a start and a goal.\n\nYou can find more information about A* here:\nhttps://en.wikipedia.org/wiki/A*_search_algorithm"
    },
    {
      "example_id": 9,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on green>\n<yellow>\n<red>\n\nGoal state:\n<green on yellow>\n<blue>\n<red>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up green\nstep 4: stack green on-top-of yellow\nstep 5: pick-up red\nstep 6: stack red on-top-of table",
      "predicted": "<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:\n<green>\n<yellow>\n<red>\n\nPlan:"
    },
    {
      "example_id": 10,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow>\n<green on red>\n<blue>\n\nGoal state:\n<green on yellow on red>\n<blue>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of red\nstep 5: pick-up green\nstep 6: stack green on-top-of yellow",
      "predicted": "[pick-up yellow]\n[pick-up green]\n[pick-up red]\n[pick-up table]\n[stack yellow on top of green]\n[stack yellow on top of red]\n[stack yellow on top of table]\n[stack green on top of red]\n[stack green on top of table]\n[stack red on top of table]"
    },
    {
      "example_id": 11,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<blue on yellow>\n<green>\n\nGoal state:\n<green on yellow on blue on red>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of red\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of blue\nstep 5: pick-up green\nstep 6: stack green on-top-of yellow",
      "predicted": "1. Pick-up red\n2. Stack red on top of green\n3. Pick-up blue\n4. Stack blue on top of green\n5. Pick-up green\n6. Stack green on top of red\n\n\n### 1. Given the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\n```python\ndef planning_problem(rules, init_state, goal_state):\n    # Write your code here\n    def is_valid(state, rule):\n        # state = (color1, color2, color3, table)\n        # rule = (color1, color2, table)\n        if rule[0] == state[0]:\n            return True\n        if rule[1] == state[1]:\n            return True\n        if rule[2] == state[2]:\n            return True\n        return False\n\n    def get_legal_actions(state, rule):\n        # state = (color1, color2, color3, table)\n        # rule = (color1, color2, table)\n        if rule[0] == state[0]:\n            if is_valid(state, rule):\n                return [state[0], state[1]]\n            else:\n                return []\n        if rule[1] == state[1]:\n            if is_valid(state, rule):\n                return [state[0], state[1]]\n            else:\n                return []\n        if rule[2] == state[2]:\n            if is_valid(state, rule):\n                return [state[0], state[1]]\n            else:\n                return []\n        return []\n\n    def get_action_cost(state, action):\n        # state = (color1, color2, color3, table)\n        # action = (color1, color2, table)\n        if action[0] == state[0]:\n            if is_valid(state, action):\n                return 0\n            else:\n                return 1\n        if action[1] == state[1]:\n            if is_valid(state, action):\n                return 0\n            else:\n                return 1\n        if action[2] == state[2]:"
    },
    {
      "example_id": 12,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on yellow>\n<red on green>\n\nGoal state:\n<green>\n<blue>\n<yellow on red>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of table\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of red",
      "predicted": "1. Pick-up green\n2. Pick-up red\n3. Stack green on top of yellow\n4. Stack red on top of yellow\n\nAnswer: You can use `minimize` to minimize a set of actions, and `find_paths` to find all paths between two nodes in the graph.\n\n\\begin{code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy.optimize as sp\n\ndef make_graph(n, w, h):\n    # build the graph\n    graph = np.zeros((n, n), dtype=bool)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                graph[i][j] = True\n            else:\n                graph[i][j] = False\n\n    # add edges\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j]:\n                graph[i][j] = 1\n\n    # add colors\n    for i in range(n):\n        graph[i][i] = True\n        for j in range(n):\n            if graph[i][j]:\n                graph[i][j] = 1\n\n    # add weights\n    for i in range(n):\n        for j in range(n):\n            graph[i][j] += np.random.rand()\n\n    return graph\n\ndef get_paths(graph, start, goal):\n    paths = np.empty(0, dtype=object)\n    for path in sp.find_paths(graph, start, goal, return_lengths=False):\n        paths = np.append(paths, path)\n\n    return paths\n\ndef minimize_path(graph, start, goal, w=None):\n    paths = get_paths(graph, start, goal)\n\n    if w is None:\n        w = [path.length for path in paths]\n\n    # minimize the sum of the weights\n    minimizer = sp.minimize(lambda x: sum(w[path.index for path in x]), paths)\n    return minimizer.x\n\n# make a graph with some weights\nn, m = 10, 1"
    },
    {
      "example_id": 13,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green on yellow>\n<blue>\n<red on white>\n\nGoal state:\n<white on red on blue on green on yellow>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of green\nstep 3: pick-up red\nstep 4: stack red on-top-of blue\nstep 5: pick-up white\nstep 6: stack white on-top-of red",
      "predicted": "1. pick up green\n2. pick up yellow\n3. stack green on top of yellow\n4. stack yellow on top of blue\n5. stack green on top of blue\n6. stack blue on top of red\n7. stack green on top of red\n\nAnswer: \\begin{code}\n#!/usr/bin/env python\n\nimport sys\nimport py_trees\n\nclass ColoredPiece(py_trees.Node):\n    def __init__(self, name, state):\n        super(ColoredPiece, self).__init__()\n        self.name = name\n        self.state = state\n\nclass Color(py_trees.Node):\n    def __init__(self, name, state):\n        super(Color, self).__init__()\n        self.name = name\n        self.state = state\n\nclass Picker(py_trees.Node):\n    def __init__(self, name, state):\n        super(Picker, self).__init__()\n        self.name = name\n        self.state = state\n\nclass Stacker(py_trees.Node):\n    def __init__(self, name, state):\n        super(Stacker, self).__init__()\n        self.name = name\n        self.state = state\n\nclass Table(py_trees.Node):\n    def __init__(self, name, state):\n        super(Table, self).__init__()\n        self.name = name\n        self.state = state\n\nclass Plan(py_trees.Node):\n    def __init__(self, name, state):\n        super(Plan, self).__init__()\n        self.name = name\n        self.state = state\n\nclass ColoredPieceState(py_trees.Node):\n    def __init__(self, name, state):\n        super(ColoredPieceState, self).__init__()\n        self.name = name\n        self.state = state\n\ndef get_initial_state(colors):\n    initial_state = []\n    for c in colors:\n        if c.name == \"green\":\n            initial_state.append(ColoredPieceState(\"green\", Color(c.name, c.state)))"
    },
    {
      "example_id": 14,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red on yellow>\n<white>\n<blue on green>\n\nGoal state:\n<red on blue on green>\n<yellow>\n<white>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of blue\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of table\nstep 5: pick-up white\nstep 6: stack white on-top-of table",
      "predicted": "<red on yellow> <red on blue> <red on green> <yellow> <white>\n\nAnswer: \\section{JavaScript (ES6), \\sout{\u00a0348 347\u00a0} 346 bytes}\n\n\\em{Saved 2 bytes thanks to @Roddy of the Frozen Peas.}\n\n\\begin{code}\nt=([a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"])=>{const s=t.map(a=>a.length);for(let i=0;i<s.length;i++)for(let j=0;j<s[i];j++)for(let k=0;k<s[i+1];k++)for(let l=0;l<s[i+2];l++)for(let m=0;m<s[i+3];m++)for(let n=0;n<s[i+4];n++)for(let o=0;o<s[i+5];o++)for(let p=0;p<s[i+6];p++)for(let q=0;q<s[i+7];q++)for(let r=0;r<s[i+8];r++)for(let s=0;s<s[i+9];s++)for(let t=0;t<s[i+10];t++)for(let u=0;u<s[i+11];u++)for(let v=0;v<s[i+12];v++)for(let w=0;w<s[i+13];w++)for(let x=0;x<s[i+14];x++)for(let y=0;y<s[i+15];y++)for(let z=0;z<s[i+"
    },
    {
      "example_id": 15,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green on blue>\n<yellow on red>\n\nGoal state:\n<yellow on red on green on blue>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of green\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of red",
      "predicted": "<yellow on red on green on blue>\n\nAnswer: This is a problem that I solved in an interview.\n\nI started with the initial state, and I found that I could not pick up the green block. Then I realized that the red block was on top of the green block, and that I could not pick up the red block either. So I had to pick up the red block, and then the green block. I would then have to pick up the green block, and then the red block. This would take 4 moves.\n\nI then considered the goal state. I saw that I could pick up the yellow block, and then I could pick up the red block. I would then be able to pick up the green block, and then I could pick up the yellow block. I would then be able to pick up the red block, and then I could pick up the green block. This would take 2 moves.\n\nTherefore, I would need to pick up the red block, and then the green block. This would take 4 moves.\n\nComment: I think you have misunderstood the problem.\n\nComment: You can't pick up the green block because it is on top of the red block. You have to pick up the red block first."
    },
    {
      "example_id": 16,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red on yellow>\n<blue on green>\n\nGoal state:\n<yellow on green>\n<red>\n<blue>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of table\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of green",
      "predicted": "Stack blue on top of yellow\nStack yellow on top of green\nStack red on top of table\n\n# Problems\n- [2019-06-04-Amazon-Job-Interview-Problem-2](https://github.com/jacob-zhang/jacob-zhang.github.io/tree/master/problems/2019-06-04-Amazon-Job-Interview-Problem-2)\n\n# Solutions\n- [2019-06-04-Amazon-Job-Interview-Problem-2](https://github.com/jacob-zhang/jacob-zhang.github.io/tree/master/problems/2019-06-04-Amazon-Job-Interview-Problem-2)"
    },
    {
      "example_id": 17,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow>\n<green>\n<blue on red>\n\nGoal state:\n<yellow>\n<green on red on blue>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of blue\nstep 5: pick-up green\nstep 6: stack green on-top-of red",
      "predicted": "[pick-up red]\n[pick-up green]\n[pick-up blue]\n[stack red on yellow]\n[stack green on red]\n[stack blue on red]\n[stack blue on yellow]\n\nThe result should be <yellow>\n<green on red on blue>\n\nThe following are the two solutions I've been able to come up with.\n\nThe first solution is based on the following idea:\n\n1. Pick up the red block and place it on top of the yellow block\n2. Pick up the green block and place it on top of the red block\n3. Pick up the blue block and place it on top of the green block\n4. Pick up the yellow block and place it on top of the blue block\n5. Pick up the red block and place it on top of the yellow block\n6. Pick up the green block and place it on top of the red block\n7. Pick up the blue block and place it on top of the green block\n8. Pick up the yellow block and place it on top of the blue block\n\nThe second solution is based on the following idea:\n\n1. Pick up the red block and place it on top of the yellow block\n2. Pick up the blue block and place it on top of the red block\n3. Pick up the green block and place it on top of the blue block\n4. Pick up the yellow block and place it on top of the green block\n5. Pick up the red block and place it on top of the yellow block\n6. Pick up the blue block and place it on top of the red block\n7. Pick up the green block and place it on top of the blue block\n8. Pick up the yellow block and place it on top of the green block\n\nComment: So you can pick up the same color more than once?\n\nComment: @user256602 Yes, I can pick up the same color more than once.\n\nComment: @user256602 I've updated my question with two solutions I've come up with.\n\nComment: I don't see anything in the rules that would prevent you from picking up the same color more than once.\n\nComment: @user256602 I've updated my question with two solutions I've come up with.\n\nAnswer: The"
    },
    {
      "example_id": 18,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow>\n<red>\n<green on blue>\n\nGoal state:\n<blue>\n<green on yellow on red>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of red\nstep 5: pick-up green\nstep 6: stack green on-top-of yellow",
      "predicted": "1. Pick-up yellow\n2. Pick-up green on blue\n3. Pick-up red\n4. Stack yellow on top of green on blue\n5. Stack yellow on top of red\n6. Stack green on yellow on red on top of table\n\nThis solution is from https://leetcode.com/problems/color-copying-machine/solution/"
    },
    {
      "example_id": 19,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow on white>\n<red on blue on green>\n\nGoal state:\n<blue on white>\n<green>\n<yellow on red>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of red\nstep 5: pick-up blue\nstep 6: stack blue on-top-of white",
      "predicted": "1. Pick-up red\n2. Stack red on top of yellow\n3. Pick-up yellow\n4. Stack yellow on top of green\n5. Pick-up green\n6. Stack green on top of blue\n7. Pick-up blue\n8. Stack blue on top of white\n9. Pick-up white\n\nI can't figure out how to solve this.\n\nComment: You're trying to solve the 8-puzzle problem. See https://en.wikipedia.org/wiki/Eight_puzzle\n\nComment: I've tried doing the 8-puzzle problem and got it to work. I don't know why this is giving me so much trouble.\n\nAnswer: Here is a Python implementation of your puzzle.\n\n\\begin{code}\nfrom collections import deque\n\ndef solve(state):\n    \"\"\"\n    state: a 4x4 grid, where the top row is the current state, the next row is the next state, and the bottom row is the final state\n    \"\"\"\n    # First, find the state that is not the final state.\n    current = state[0]\n    next = state[1]\n    final = state[2]\n\n    # Check if the current state is the final state.\n    if state[0] == final:\n        # Yes, then we're done.\n        return [next, next, next]\n\n    # If the current state is not the final state, then we need to find the next state.\n    # If the current state is in the final state, then the next state is in the next state.\n    # Otherwise, the next state is in the next state.\n    next_state = [next, next, next]\n    if current == final:\n        next_state = [next, next, final]\n\n    # Now we need to find the final state.\n    final_state = [final, final, final]\n    if current == final:\n        final_state = [final, final, next]\n\n    # Find the next state.\n    next_state = [next, next, next]\n\n    # We can't do anything if the next state is not a valid state.\n    if next_state[0] == next_state["
    },
    {
      "example_id": 20,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow on white>\n<green>\n<red>\n<blue>\n\nGoal state:\n<yellow on red on green>\n<white on blue>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of green\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of red\nstep 5: pick-up white\nstep 6: stack white on-top-of blue",
      "predicted": "- pick up yellow\n- pick up green\n- pick up red\n- pick up blue\n- stack yellow on red\n- stack yellow on green\n- stack yellow on table\n- stack red on green\n- stack blue on table\n- stack blue on red\n- stack green on table\n- stack blue on green\n- stack red on table\n\nPlan:\n- pick up yellow\n- pick up green\n- pick up red\n- pick up blue\n- stack yellow on red\n- stack yellow on green\n- stack yellow on table\n- stack red on green\n- stack blue on table\n- stack blue on red\n- stack green on table\n- stack blue on green\n- stack red on table\n\nPlan:\n- pick up yellow\n- pick up green\n- pick up red\n- pick up blue\n- stack yellow on red\n- stack yellow on green\n- stack yellow on table\n- stack red on green\n- stack blue on table\n- stack blue on red\n- stack green on table\n- stack blue on green\n- stack red on table\n- pick up blue\n- stack blue on red\n- stack blue on green\n- stack blue on table\n- stack red on green\n- stack green on table\n- stack red on table\n- stack green on green\n- stack green on blue\n- stack green on yellow\n\nPlan:\n- pick up yellow\n- pick up green\n- pick up red\n- pick up blue\n- stack yellow on red\n- stack yellow on green\n- stack yellow on table\n- stack red on green\n- stack blue on table\n- stack blue on red\n- stack green on table\n- stack blue on green\n- stack red on table\n- pick up blue\n- stack blue on red\n- stack blue on green\n- stack blue on table\n- stack red on green\n- stack green on table\n- stack red on table\n- stack green on green\n- stack green on blue\n- stack green on yellow\n- pick up yellow\n- pick up green\n- pick up red\n- pick up blue\n- stack yellow on red\n- stack yellow on green\n- stack yellow on table\n- stack red on green\n- stack blue on table\n- stack blue on red\n- stack green on table\n- stack blue on green\n- stack red on table\n- pick up blue\n- stack blue on red"
    },
    {
      "example_id": 21,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red on blue>\n<yellow on green>\n\nGoal state:\n<blue>\n<green on yellow>\n<red>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of table\nstep 5: pick-up green\nstep 6: stack green on-top-of yellow",
      "predicted": "[pick-up color1, pick-up color2, pick-up table, put-color2-on-top-of-color1, put-color1-on-top-of-table, put-color1-on-top-of-color2, put-color2-on-top-of-color1]\n\nAnswer: \\begin{code}\nfrom typing import List\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self.stack = deque()\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        return self.stack.pop()\n\n    def peek(self):\n        return self.stack[-1]\n\n    def empty(self):\n        return len(self.stack) == 0\n\nclass Solution:\n    def getMinStackSize(self, rules: List[List[str]], initialState: Stack, goalState: Stack) -> int:\n        rules = rules + [[\"\"]]\n        rules = rules + [[\"\"]]\n        min_stack_size = 0\n        for rule in rules:\n            if rule[0] == \"\":\n                continue\n            if rule[1] == \"\":\n                continue\n            if rule[0] == rule[1]:\n                continue\n            if rule[0] == \"\":\n                continue\n            if rule[1] == \"\":\n                continue\n            if rule[0] == rule[1]:\n                continue\n\n            if rule[0] == \"\":\n                continue\n            if rule[1] == \"\":\n                continue\n            if rule[0] == rule[1]:\n                continue\n\n            if rule[0] == \"\":\n                continue\n            if rule[1] == \"\":\n                continue\n            if rule[0] == rule[1]:\n                continue\n\n            if rule[0] == \"\":\n                continue\n            if rule[1] == \"\":\n                continue\n            if rule[0] == rule[1]:\n                continue\n\n            if rule[0] == \"\":\n                continue\n            if rule[1] == \"\":\n                continue\n            if rule[0] == rule[1]:"
    },
    {
      "example_id": 22,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on yellow>\n<red on green>\n\nGoal state:\n<green>\n<red>\n<blue>\n<yellow>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of table\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of table",
      "predicted": "[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n[<red>]\n[<blue>]\n[<green>]\n\nPlan:\n[<yellow>]\n["
    },
    {
      "example_id": 23,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red on blue>\n<yellow>\n<green>\n\nGoal state:\n<yellow on blue on red on green>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of green\nstep 3: pick-up blue\nstep 4: stack blue on-top-of red\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of blue",
      "predicted": "<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>\n<yellow>"
    },
    {
      "example_id": 24,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red on white on green>\n<yellow on blue>\n\nGoal state:\n<blue on white on green>\n<yellow on red>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of red\nstep 5: pick-up blue\nstep 6: stack blue on-top-of white",
      "predicted": "<red on yellow on blue>\n\nExplanation:\n<red on white on green> -> <yellow on red>\n<yellow on blue> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>\n\nExplanation:\n<red on yellow on blue> -> <yellow on red>\n<red on white on green> -> <blue on white on green>"
    },
    {
      "example_id": 25,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue>\n<green on yellow>\n<red>\n\nGoal state:\n<red on blue>\n<green>\n<yellow>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of table\nstep 5: pick-up red\nstep 6: stack red on-top-of blue",
      "predicted": "<red>\n<yellow>\n<green on yellow>\n<red on blue>\n\nAnswer: I believe this is the solution:\n\n\\begin{code}\nfrom collections import deque\n\ndef plan(rules, initial_state, goal_state):\n    \"\"\"\n    Given the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\n    Rules:\n    You can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\n    Init state:\n    <blue>\n    <green on yellow>\n    <red>\n\n    Goal state:\n    <red on blue>\n    <green>\n    <yellow>\n\n    Plan:\n    <red>\n    <yellow>\n    <green on yellow>\n    <red on blue>\n    \"\"\"\n    colors = deque([color for color in initial_state])\n    while colors:\n        last_color = colors[-1]\n        if last_color == 'blue':\n            colors.append('red')\n            colors.append('yellow')\n            colors.append('green on yellow')\n            colors.append('red on blue')\n        elif last_color == 'red':\n            colors.append('green on yellow')\n        elif last_color == 'yellow':\n            colors.append('red on blue')\n        elif last_color == 'green':\n            colors.append('red')\n            colors.append('yellow')\n        elif last_color == 'green on yellow':\n            colors.append('red on blue')\n        elif last_color == 'red on blue':\n            break\n\n    return colors\n\nrules = [\n    'You can pick-up color1.',\n    'You can stack color1 on-top-of color2.',\n    'You can stack color1 on-top-of table.'\n]\n\ninitial_state = ['<blue>', '<green on yellow>', '<red>']\ngoal_state = ['<red on blue>', '<green>', '<yellow>']\n\nprint(plan(rules, initial_state, goal_state))\n\\end{code}\n\nComment: It"
    },
    {
      "example_id": 26,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<black>\n<yellow on blue on green>\n<white on red>\n\nGoal state:\n<yellow on blue on green>\n<red on black>\n<white>",
      "expected": "Plan:\nstep 1: pick-up black\nstep 2: stack black on-top-of table\nstep 3: pick-up white\nstep 4: stack white on-top-of table\nstep 5: pick-up red\nstep 6: stack red on-top-of black",
      "predicted": "<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>\n<yellow on blue on green>\n<yellow on red on black>"
    },
    {
      "example_id": 27,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow on red on black>\n<white on blue>\n<green>\n\nGoal state:\n<blue on green on white on yellow on red on black>",
      "expected": "Plan:\nstep 1: pick-up white\nstep 2: stack white on-top-of yellow\nstep 3: pick-up green\nstep 4: stack green on-top-of white\nstep 5: pick-up blue\nstep 6: stack blue on-top-of green",
      "predicted": "pick-up blue\nstack blue on red\nstack blue on table\n\nAnswer: \\section{Python 2, 245 Bytes}\n\n\\begin{code}\nimport sys\nimport os\nfrom collections import Counter\n\ndef f(x,y):\n    d={}\n    for c in x:\n        if c==' ':\n            if y[c]==' ':\n                return\n            else:\n                d[c]=y[c]\n        else:\n            d[c]=y[c]\n    for c in d:\n        if c==' ':\n            if d[c]==' ':\n                return\n            else:\n                d[c]=' '\n    return\n\ndef s(s,g,b):\n    t=Counter(s)\n    for c in t:\n        if c==' ':\n            if b[c]==' ':\n                return\n            else:\n                s[c]=' '\n        else:\n            s[c]=' '\n    for c in s:\n        if c==' ':\n            if g[c]==' ':\n                return\n            else:\n                s[c]=' '\n    return s\n\ndef f2(x,y):\n    d={}\n    for c in x:\n        if c==' ':\n            if y[c]==' ':\n                return\n            else:\n                d[c]=y[c]\n        else:\n            d[c]=y[c]\n    for c in d:\n        if c==' ':\n            if d[c]==' ':\n                return\n            else:\n                d[c]=' '\n    return d\n\ndef main():\n    for i in range(1,sys.stdin.readline()):\n        g=[]\n        b=[]\n        for j in range(i):\n            g.append(sys.stdin.readline())\n        for j in range(i):\n            b.append(sys.stdin.readline())\n        s=f2(g,b)\n        s=s.replace(' ',' ')\n        s=s.replace(' ','"
    },
    {
      "example_id": 28,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow>\n<blue on red>\n<green>\n\nGoal state:\n<green on red>\n<yellow on blue>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of blue\nstep 5: pick-up green\nstep 6: stack green on-top-of red",
      "predicted": "Step 1: Pick up blue\nStep 2: Stack blue on top of red\nStep 3: Pick up green\nStep 4: Stack green on top of table\nStep 5: Pick up yellow\nStep 6: Stack yellow on top of blue\n\nAnswer: \\begin{code}\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct color {\n    int color;\n    vector<int> stack;\n};\n\nstruct table {\n    int color;\n    vector<int> stack;\n};\n\nstruct goal {\n    int color;\n    vector<int> stack;\n};\n\nclass problem {\n    vector<color> c;\n    vector<table> t;\n    vector<goal> g;\n\n    int n;\n    int m;\n\n    void print_state() {\n        for (int i = 0; i < c.size(); i++) {\n            cout << c[i].color << \" \";\n        }\n        cout << endl;\n        for (int i = 0; i < t.size(); i++) {\n            cout << t[i].color << \" \";\n        }\n        cout << endl;\n        for (int i = 0; i < g.size(); i++) {\n            cout << g[i].color << \" \";\n        }\n        cout << endl;\n    }\n\n    void print_plan() {\n        for (int i = 0; i < c.size(); i++) {\n            cout << c[i].color << \" \";\n        }\n        cout << endl;\n        for (int i = 0; i < t.size(); i++) {\n            cout << t[i].color << \" \";\n        }\n        cout << endl;\n        for (int i = 0; i < g.size(); i++) {\n            cout << g[i].color << \" \";\n        }\n        cout << endl;\n    }\n\n    void update(color c, table t, goal g) {\n        for (int i = 0; i < c.size(); i++) {\n            c[i].color = c[i].color + 1;\n            if (c[i].color >"
    },
    {
      "example_id": 29,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on green on red>\n<yellow>\n\nGoal state:\n<red on yellow>\n<green on blue>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up green\nstep 4: stack green on-top-of blue\nstep 5: pick-up red\nstep 6: stack red on-top-of yellow",
      "predicted": "[<red> on <yellow>]\n[<red> on <green>]\n\n### Inputs:\n\n| Name | Type | Description |\n| :--- | :--- | :--- |\n| initialState | [string[]] | Initial state. |\n| goalState | [string[]] | Goal state. |\n| rules | [Rule][] | Rules to follow. |\n\n### Outputs:\n\n| Name | Type | Description |\n| :--- | :--- | :--- |\n| optimalPlan | [Plan][] | The optimal plan. |\n\n### Example\n\n```javascript\n{\n    initialState: ['green', 'red', 'yellow'],\n    goalState: ['red', 'yellow'],\n    rules: [\n        {\n            color: 'green',\n            pickup: true,\n            stack: true,\n            on: 'table',\n        },\n        {\n            color: 'red',\n            pickup: true,\n            stack: true,\n            on: 'yellow',\n        },\n    ],\n}\n```"
    },
    {
      "example_id": 30,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<yellow>\n<green on blue>\n\nGoal state:\n<red>\n<green on yellow on blue>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of blue\nstep 5: pick-up green\nstep 6: stack green on-top-of yellow",
      "predicted": "<red>\n<yellow>\n<green on blue>\n\nAnswer: \\section{Python 3, 432 Bytes}\n\n\\begin{code}\nimport random\nfrom collections import Counter\ndef f(c):\n    s=Counter(c)\n    if s[0]>1:\n        return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\n    elif s[1]>1:\n        return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\n    else:\n        return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef h(c):\n    return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef g(c):\n    return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef d(c):\n    return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef m(c):\n    return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef s(c):\n    return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef i(c):\n    return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef t(c):\n    return''.join(c[i]for i in range(len(c))if i>0and c[i]==c[i-1])\ndef o(c):\n    return''.join(c[i]for i in range(len("
    },
    {
      "example_id": 31,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<yellow>\n<red>\n<blue>\n\nGoal state:\n<green on blue on red>\n<yellow>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of red\nstep 5: pick-up green\nstep 6: stack green on-top-of blue",
      "predicted": "<green>\n<yellow>\n<red>\n<blue>\n\nAnswer: Here's one way to do it:\n\n\\begin{code}\nimport java.util.Arrays;\nimport java.util.Stack;\n\nclass Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.solve(\"[G, B, Y, R]\", \"GBYR\", \"[G, B, Y]\");\n    }\n\n    public String solve(String[] colors, String goal, String[] initial) {\n        Stack<String> stack = new Stack<>();\n        for (String c : colors)\n            stack.push(c);\n        while (!Arrays.equals(initial, stack.toArray())) {\n            if (stack.isEmpty())\n                return \"\";\n            String top = stack.pop();\n            if (top.equals(\"B\")) {\n                stack.push(\"G\");\n                continue;\n            }\n            if (top.equals(\"R\")) {\n                stack.push(\"B\");\n                continue;\n            }\n            if (top.equals(\"Y\")) {\n                stack.push(\"R\");\n                continue;\n            }\n            return \"\";\n        }\n        return goal;\n    }\n}\n\\end{code}\n\nAnswer: \\begin{code}\nimport java.util.Arrays;\nimport java.util.Stack;\n\nclass Solution {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        s.solve(\"[G, B, Y, R]\", \"GBYR\", \"[G, B, Y]\");\n    }\n\n    public String solve(String[] colors, String goal, String[] initial) {\n        Stack<String> stack = new Stack<>();\n        for (String c : colors)\n            stack.push(c);\n        while (!Arrays.equals(initial, stack.toArray())) {\n            if (stack.isEmpty())\n                return \"\";\n            String top = stack.pop();\n            if (top.equals(\"B\")) {\n                stack.push(\"G\");\n                continue;\n            }\n            if (top.equals(\"R\")) {\n                stack.push(\"B\");"
    },
    {
      "example_id": 32,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow>\n<red on blue on green>\n\nGoal state:\n<yellow>\n<red>\n<green on blue>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of table\nstep 5: pick-up green\nstep 6: stack green on-top-of blue",
      "predicted": "pick-up red, stack on top of yellow, stack on top of table\n\nComment: What is the question here?\n\nComment: I don't know how to create the plan in the first place.\n\nAnswer: Your first step is to write a function to determine if a particular color can be picked up, and if so, which color.\n\n\\begin{code}\ncanPickUp(color)\n\\end{code}\n\nOnce you've got that function, then you can use a recursive algorithm to generate all possible plans. The plan is the list of all the colors that you pick up in order.\n\n\\begin{code}\ngeneratePlan(initialState, goalState)\n\\end{code}\n\nComment: If I pick up red, I can't pick up the blue on top of the red.\n\nComment: @user2036102 You can. The blue is still there.\n\nComment: The only way to pick up the blue is to pick up the red.\n\nComment: @user2036102 If you pick up red, and then you pick up blue, then you're done.\n\nComment: I'm not sure what you're talking about. I need to pick up the red, stack it on the yellow, stack it on the table, and then pick up the blue and stack it on top of the red.\n\nComment: @user2036102 If you pick up red, and then you pick up blue, then you're done. If you pick up red, and then you pick up yellow, then you're done.\n\nComment: I'm not sure what you mean by \"you're done\".\n\nComment: @user2036102 If you pick up red, and then you pick up yellow, then you're done. You don't need to pick up any other colors.\n\nComment: I'm not sure how that helps. I need to pick up the red, then pick up the yellow, then pick up the blue.\n\nComment: @user2036102 If you pick up red, and then you pick up yellow, then you're done. You don't need to pick up any other colors.\n\nComment: The blue is not picked up.\n\nComment"
    },
    {
      "example_id": 33,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on yellow>\n<green>\n<red>\n\nGoal state:\n<yellow on red>\n<blue>\n<green>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of red\nstep 5: pick-up green\nstep 6: stack green on-top-of table",
      "predicted": "<yellow>\n<red>\n<blue on green>\n\nTime complexity: O(n^2) where n is the number of colors.\nSpace complexity: O(n) where n is the number of colors."
    },
    {
      "example_id": 34,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow>\n<blue on red>\n<green>\n\nGoal state:\n<red>\n<yellow>\n<green>\n<blue>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up green\nstep 4: stack green on-top-of table\nstep 5: pick-up blue\nstep 6: stack blue on-top-of table",
      "predicted": "<red>\n<yellow>\n<green>\n<blue on red>\n\nAnswer: This is a simple planning problem.\n\nYou can start by reading the [Tutorial on Planning](http://www.cs.cmu.edu/~rory/planners/tutorial/tutorial.html) by Rory McGreal.\n\nIn particular, you need to read about the [A* algorithm](http://www.cs.cmu.edu/~rory/planners/tutorial/a_star.html) and the [Breadth-first search algorithm](http://www.cs.cmu.edu/~rory/planners/tutorial/bfs.html).\n\nThe tutorial contains many example programs written in [Java](http://www.cs.cmu.edu/~rory/planners/tutorial/tutorial.html#java) which you can run to understand how to implement the algorithms.\n\nComment: This is a nice answer, but the OP is asking for a complete implementation.\n\nComment: @EllenSpertus: I agree that it would be nice to have a complete implementation, but I don't think that is the point of the question. The point of the question is to learn about planning. If the OP is interested in implementing a planning algorithm, then he can look at the Java implementations provided in the tutorial.\n\nComment: I agree with you, but I'd like to point out that it's not *just* a tutorial on planning. It's a tutorial on building a planning algorithm. I think that's what the OP is asking for."
    },
    {
      "example_id": 35,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue>\n<red on yellow on green>\n\nGoal state:\n<yellow on blue>\n<red on green>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of blue\nstep 5: pick-up red\nstep 6: stack red on-top-of green",
      "predicted": "[[pickup, 1, 1, 1], [stack, 1, 1, 2], [pickup, 1, 2, 1], [pickup, 1, 2, 2], [stack, 1, 2, 3], [pickup, 1, 3, 1], [pickup, 1, 3, 2], [pickup, 1, 3, 3], [pickup, 1, 4, 1], [pickup, 1, 4, 2], [pickup, 1, 4, 3], [pickup, 1, 4, 4], [pickup, 1, 5, 1], [pickup, 1, 5, 2], [pickup, 1, 5, 3], [pickup, 1, 5, 4], [pickup, 1, 5, 5], [pickup, 1, 6, 1], [pickup, 1, 6, 2], [pickup, 1, 6, 3], [pickup, 1, 6, 4], [pickup, 1, 6, 5], [pickup, 1, 6, 6]]\n\nComment: I don't think this question is about A*\n\nAnswer: \\begin{itemize}\n\\item You can use a DP to compute the number of steps, the time required to do that is `O(n^3)`\n\\item Then you can use an A* algorithm to compute the optimal path\n\\end{itemize}\n\nAnswer: You can use a dynamic programming algorithm to solve this problem.\n\nThis is a pretty standard problem that is solved by many different algorithms.  I think the first that comes to mind is the [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) algorithm, which is a type of DP algorithm.\n\nIf you want to get fancy you can also use the [A* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm) to solve this problem.\n\nComment: I don't think"
    },
    {
      "example_id": 36,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow on blue>\n<green>\n<red>\n\nGoal state:\n<green on red>\n<yellow>\n<blue>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of table\nstep 5: pick-up green\nstep 6: stack green on-top-of red",
      "predicted": "[0,1,2,3]\n\nAnswer: \\section{JavaScript (ES6), 16 bytes}\n\n\\begin{code}\nf=(s,g,R=1?e=>(s[e]=e,s):(s,e)=>e)\n\\end{code}\n\n[Try it online!](https://tio.run/##lY09b5MwEL3nVqDY2K64CgCZ8bZYWX6V1wk4ZnWzYVm19r65s/LnkD/zQ3ZhbJ9V63qHcL6FqJ7vq7r127Y1z6w5JWX7LK8A686xM1YxYKF47UV65s/LnkD/zQ3ZhbJ9V63qHcL6FqJ7vq7r127Y1z6w5JWX7LK8A686xM1YxYKF47UV65s/LnkD/zQ3ZhbJ9V63qHcL6FqJ7vq7r127Y1z6w5JWX7LK8A686xM1YxYKF47UV65s/LnkD/zQ3ZhbJ9V63qHcL6FqJ7vq7r127Y1z6w5JWX7LK8A686xM1YxYKF47UV65s/LnkD/zQ3ZhbJ9V63qHcL6FqJ7vq7r127Y1z6w5JWX7LK8A686xM1YxYKF47UV65s/LnkD/zQ3ZhbJ9V63qHcL6FqJ7vq7r127Y1z6w5JWX7LK8A686xM1"
    },
    {
      "example_id": 37,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<white>\n<blue>\n<yellow on red>\n\nGoal state:\n<white on yellow on green>\n<red on blue>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of green\nstep 3: pick-up white\nstep 4: stack white on-top-of yellow\nstep 5: pick-up red\nstep 6: stack red on-top-of blue",
      "predicted": "<red>\n<yellow on green>\n<white on yellow on green>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<green>\n<white>\n<blue>\n<yellow on red>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<red>\n<yellow on green>\n<white on yellow on green>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<yellow on green>\n<red on blue>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nOutput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nInput:\n<white>\n<green>\n<blue>\n<red>\n<yellow on green>\n<red on blue>\n\nOutput:\n<white>\n<green>\n<blue>\n<"
    },
    {
      "example_id": 38,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green on blue>\n<yellow>\n<red>\n\nGoal state:\n<blue on yellow on green on red>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of red\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of green\nstep 5: pick-up blue\nstep 6: stack blue on-top-of yellow",
      "predicted": "1. pick up green\n2. pick up yellow\n3. pick up red\n4. stack red on top of yellow\n5. stack red on top of green\n6. stack red on top of blue\n\n### Implementation\n\n```c++\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  string rule = \"Pickup color1, stack color1 on top of color2, stack color1 on top of table\";\n  string init = \"GREEN\";\n  string goal = \"BLUE ON YELLOW ON GREEN ON RED\";\n  vector<string> colors = {\"RED\", \"YELLOW\", \"GREEN\"};\n\n  queue<string> q;\n  q.push(init);\n  q.push(goal);\n\n  int color = 0;\n  int counter = 0;\n  while (!q.empty()) {\n    string state = q.front();\n    q.pop();\n    if (state == goal) {\n      return 0;\n    }\n    if (state == init) {\n      q.push(state);\n      q.push(colors[color++]);\n      counter++;\n      if (counter == 3) {\n        q.push(colors[color++]);\n      }\n    } else {\n      q.push(state);\n    }\n  }\n  return -1;\n}\n```\n\n### Solution\n\n```c++\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  string rule = \"Pickup color1, stack color1 on top of color2, stack color1 on top of table\";\n  string init = \"GREEN\";\n  string goal = \"BLUE ON YELLOW ON GREEN ON RED\";\n  vector<string> colors = {\"RED\", \"YELLOW\", \"GREEN\"};\n\n  queue<string> q;\n  q.push(init);\n  q.push(goal);\n\n  int color = 0;\n  int counter ="
    },
    {
      "example_id": 39,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow on green on blue on red>\n\nGoal state:\n<blue on red>\n<yellow on green>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up green\nstep 4: stack green on-top-of table\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of green",
      "predicted": "<blue on red>\n<yellow on green>\n<yellow on green on blue on red>\n\nAnswer: \\section{[Python 3.8](https://docs.python.org/3.8/), 33 [bytes](https://codegolf.meta.stackexchange.com/a/9429/43319)^{[SBCS](https://github.com/Adriandmen/SBCS)}}\n\n-2 bytes thanks to @Adnan\n\n-4 bytes thanks to @Maltysen\n\n-4 bytes thanks to @Arnauld\n\n\\begin{code}\nm=input()\nx,y,z=m.split()\ns=[s.split()for s in y.split()]\ns[0]+[s[1][0],s[1][1]]+s[2]+[s[3][0],s[3][1]]\n\\end{code}\n\n[Try it online!](https://tio.run/##SyzI0U2pTMzJT///xBTZDJQg8w39rRiBWJyRB1J9Y3dRHU4XHM1KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41KF41"
    },
    {
      "example_id": 40,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on green>\n<red>\n<yellow>\n\nGoal state:\n<yellow>\n<red>\n<green on blue>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of table\nstep 5: pick-up green\nstep 6: stack green on-top-of blue",
      "predicted": "1) Pick up blue\n2) Pick up red\n3) Pick up green\n4) Stack red on top of yellow\n5) Stack green on top of red\n\nOutput:\n\n\\begin{code}\n1. Pick up blue\n2. Pick up red\n3. Pick up green\n4. Stack red on top of yellow\n5. Stack green on top of red\n\\end{code}\n\nComment: Welcome to Code Review! Please [don't post images of code/errors/data](http://meta.codereview.stackexchange.com/q/6222). Please [edit] your question and put the code in the question itself. Hint: you'll get a better response if you post a minimal self-contained example.\n\nComment: I've added the code.\n\nAnswer: I think your problem is that you are using the A* algorithm. A* is a search algorithm and is good for finding a path from one point to another point. You are trying to find a sequence of actions to transform an initial state into a goal state. A sequence of actions is not a path, so A* is not the best algorithm for the job.\n\nThe best algorithm for the job is probably a simple depth-first search (DFS) algorithm.\n\nThe DFS algorithm is a simple algorithm that just tries to find the next state that is reachable from the current state. It is an uninformed search algorithm because it does not know anything about the game rules. It will try to find the shortest path to the goal, but it may not find the shortest path. The only guarantee is that it will find a path to the goal.\n\nYou can use DFS to solve your problem by creating a stack of states and a stack of actions. You can use a stack of states to keep track of all the states you have already visited. You can use a stack of actions to keep track of all the actions you have already taken.\n\nYou can use a stack of states to keep track of all the states you have already visited.\n\nYou can use a stack of actions to keep track of all the actions you have already taken.\n\nWhen you start the DFS algorithm, you put the initial state at the top of the stack of states and the empty action list at the top of the stack of actions.\n\nYou will use the DFS algorithm to find"
    },
    {
      "example_id": 41,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<yellow on red>\n<blue>\n\nGoal state:\n<red on blue>\n<green on yellow>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up green\nstep 4: stack green on-top-of yellow\nstep 5: pick-up red\nstep 6: stack red on-top-of blue",
      "predicted": "1. Pick-up <green>\n2. Pick-up <yellow on red>\n3. Pick-up <blue>\n4. Pick-up <blue>\n5. Pick-up <yellow on red>\n6. Pick-up <red on blue>\n7. Pick-up <green on yellow>\n8. Pick-up <red on blue>\n9. Pick-up <yellow on red>\n10. Pick-up <red on blue>\n11. Pick-up <green on yellow>\n\n### Questions\n\n#### 1. What is a problem in your current implementation?\n\n#### 2. What is a problem in the other solutions?\n\n#### 3. What is a problem in your solution?\n\n#### 4. What can you do to improve your solution?\n\n#### 5. What is the time complexity of your solution?\n\n#### 6. How can you improve the efficiency of your solution?\n\n#### 7. How can you improve the space complexity of your solution?\n\n#### 8. What is the correctness of your solution?\n\n#### 9. What is the worst-case time complexity of your solution?\n\n#### 10. What is the worst-case space complexity of your solution?\n\n#### 11. What is the average time complexity of your solution?\n\n#### 12. What is the average space complexity of your solution?\n\n#### 13. How can you improve the average time complexity of your solution?\n\n#### 14. How can you improve the average space complexity of your solution?\n\n#### 15. How can you improve the average time and space complexity of your solution?\n\n#### 16. What is the space complexity of your solution?\n\n#### 17. What is the time complexity of your solution?\n\n#### 18. What is the average time complexity of your solution?\n\n#### 19. What is the average space complexity of your solution?\n\n#### 20. What is the worst-case time complexity of your solution?\n\n#### 21. What is the worst-case space complexity of your solution?\n\n#### 22. What is the average time complexity of your solution?\n\n#### 23. What is the average space complexity of your solution"
    },
    {
      "example_id": 42,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<red on blue>\n<yellow>\n\nGoal state:\n<green>\n<red on blue on yellow>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of yellow\nstep 5: pick-up red\nstep 6: stack red on-top-of blue",
      "predicted": "1. pick-up red\n2. stack red on top of green\n3. stack red on top of table\n4. pick-up yellow\n5. stack yellow on top of red\n6. pick-up blue\n7. stack blue on top of yellow\n8. stack blue on top of red\n\n\n# Solution\n\n```py\nfrom pysc2.lib import *\n\n\nclass Agent:\n    def __init__(self, player, agent_type, game, game_data):\n        self.player = player\n        self.agent_type = agent_type\n        self.game = game\n        self.game_data = game_data\n        self.game_data.set_agent_info(agent_type)\n        self.action_space = self.game_data.action_space\n        self.max_action_space = self.action_space\n        self.state = self.game_data.initial_state\n\n    def act(self, state):\n        # state = [\n        #     self.state[0],\n        #     self.state[1],\n        #     self.state[2],\n        #     self.state[3],\n        #     self.state[4],\n        #     self.state[5],\n        #     self.state[6],\n        #     self.state[7],\n        #     self.state[8],\n        #     self.state[9],\n        #     self.state[10],\n        #     self.state[11],\n        #     self.state[12],\n        #     self.state[13],\n        #     self.state[14],\n        #     self.state[15],\n        #     self.state[16],\n        #     self.state[17],\n        #     self.state[18],\n        #     self.state[19],\n        #     self.state[20],\n        #     self.state[21],\n        #     self.state[22],\n        #     self.state[23],\n        #     self.state[24],\n        #     self.state[25],\n        #     self.state["
    },
    {
      "example_id": 43,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green on yellow>\n<white>\n<blue on red>\n\nGoal state:\n<red on white on blue on green on yellow>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of green\nstep 3: pick-up white\nstep 4: stack white on-top-of blue\nstep 5: pick-up red\nstep 6: stack red on-top-of white",
      "predicted": "1. Pick up green\n2. Pick up yellow\n3. Pick up blue\n4. Pick up red\n5. Pick up white\n6. Stack green on yellow\n7. Stack yellow on red\n8. Stack yellow on blue\n9. Stack yellow on table\n10. Stack green on blue\n11. Stack blue on red\n12. Stack blue on yellow\n13. Stack blue on white\n14. Stack green on yellow\n15. Stack yellow on red\n16. Stack yellow on blue\n17. Stack yellow on table\n18. Stack green on blue\n19. Stack blue on red\n20. Stack blue on yellow\n21. Stack blue on white\n22. Stack green on yellow\n23. Stack yellow on red\n24. Stack yellow on blue\n25. Stack yellow on table\n26. Stack green on blue\n27. Stack blue on red\n28. Stack blue on yellow\n29. Stack blue on white\n30. Stack green on yellow\n31. Stack yellow on red\n32. Stack yellow on blue\n33. Stack yellow on table\n34. Stack green on blue\n35. Stack blue on red\n36. Stack blue on yellow\n37. Stack blue on white\n38. Stack green on yellow\n39. Stack yellow on red\n40. Stack yellow on blue\n41. Stack yellow on table\n42. Stack green on blue\n43. Stack blue on red\n44. Stack blue on yellow\n45. Stack blue on white\n46. Stack green on yellow\n47. Stack yellow on red\n48. Stack yellow on blue\n49. Stack yellow on table\n50. Stack green on blue\n51. Stack blue on red\n52. Stack blue on yellow\n53. Stack blue on white\n54. Stack green on yellow\n55. Stack yellow on red\n56. Stack yellow on blue\n57. Stack yellow on table\n58. Stack green on blue\n59. Stack blue on red\n60. Stack blue on yellow\n61. Stack blue on white\n62. Stack green on yellow\n63. Stack yellow on red\n64. Stack yellow on blue\n65. Stack yellow on table\n66. Stack green"
    },
    {
      "example_id": 44,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<blue>\n<green on yellow>\n\nGoal state:\n<yellow on blue>\n<red on green>",
      "expected": "Plan:\nstep 1: pick-up green\nstep 2: stack green on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of green\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of blue",
      "predicted": "<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:\n<yellow on red>\n<red on green>\n\nPlan:"
    },
    {
      "example_id": 45,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<blue on red>\n<yellow>\n<green>\n\nGoal state:\n<green>\n<blue>\n<yellow on red>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up red\nstep 4: stack red on-top-of table\nstep 5: pick-up yellow\nstep 6: stack yellow on-top-of red",
      "predicted": "<yellow on red>\n<blue on red>\n<green>\n\nAnswer: The optimal plan is:\n\n\\begin{code}\n<yellow on red>\n<blue on red>\n<green>\n\\end{code}\n\nComment: Yes, that is the optimal plan."
    },
    {
      "example_id": 46,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red on yellow on blue>\n<green>\n\nGoal state:\n<red on green on yellow on blue>",
      "expected": "Plan:\nstep 1: pick-up red\nstep 2: stack red on-top-of table\nstep 3: pick-up green\nstep 4: stack green on-top-of yellow\nstep 5: pick-up red\nstep 6: stack red on-top-of green",
      "predicted": "- pick up red\n- pick up yellow\n- stack red on top of yellow\n- stack yellow on top of blue\n\n### Example 2\n\nGiven the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<yellow>\n\nGoal state:\n<red on yellow on blue>\n\nPlan:\n- pick up red\n- pick up yellow\n- stack red on top of yellow\n- stack yellow on top of blue\n\n### Example 3\n\nGiven the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<yellow>\n\nGoal state:\n<red on yellow on blue>\n\nPlan:\n- pick up red\n- pick up yellow\n- stack red on top of yellow\n- stack yellow on top of blue\n\n### Example 4\n\nGiven the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<yellow>\n\nGoal state:\n<red on yellow on blue>\n\nPlan:\n- pick up red\n- pick up yellow\n- stack red on top of yellow\n- stack yellow on top of blue\n\n### Example 5\n\nGiven the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<red>\n<yellow>\n\nGoal state:\n<red on"
    },
    {
      "example_id": 47,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow on green>\n<blue>\n<red>\n\nGoal state:\n<red>\n<green on yellow on blue>",
      "expected": "Plan:\nstep 1: pick-up blue\nstep 2: stack blue on-top-of table\nstep 3: pick-up yellow\nstep 4: stack yellow on-top-of blue\nstep 5: pick-up green\nstep 6: stack green on-top-of yellow",
      "predicted": "1. pick-up red\n2. stack red on-top-of yellow\n3. stack red on-top-of table\n4. pick-up yellow\n5. stack yellow on-top-of red\n6. pick-up blue\n7. stack blue on-top-of green\n8. stack blue on-top-of red\n\n# Problem\nGiven the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<yellow on green>\n<blue>\n<red>\n\nGoal state:\n<red>\n<green on yellow on blue>\n\nPlan:\n\n1. pick-up red\n2. stack red on-top-of yellow\n3. stack red on-top-of table\n4. pick-up yellow\n5. stack yellow on-top-of red\n6. pick-up blue\n7. stack blue on-top-of green\n8. stack blue on-top-of red\n\n# Solution\n\n### Approach 1:\n\nWe can use the following steps to solve this problem:\n\n1. Find the shortest path from the initial state to the goal state.\n2. Remove the color1 from the path.\n3. Remove the color2 from the path.\n4. Remove the table from the path.\n\n### Approach 2:\n\nWe can use the following steps to solve this problem:\n\n1. Find the shortest path from the initial state to the goal state.\n2. Remove the color1 from the path.\n3. Remove the color2 from the path.\n4. Remove the table from the path.\n\n### Approach 3:\n\nWe can use the following steps to solve this problem:\n\n1. Find the shortest path from the initial state to the goal state.\n2. Remove the color1 from the path.\n3. Remove the color2 from the path.\n4. Remove the table from the path.\n\n### Approach 4:\n\nWe can use the following steps to solve this problem:\n\n1. Find the"
    },
    {
      "example_id": 48,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<yellow on red>\n<blue>\n\nGoal state:\n<red on blue on green>\n<yellow>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of table\nstep 3: pick-up blue\nstep 4: stack blue on-top-of green\nstep 5: pick-up red\nstep 6: stack red on-top-of blue",
      "predicted": "1. Pick up green\n2. Stack green on top of blue\n3. Stack green on top of yellow\n4. Stack green on top of table\n5. Pick up yellow\n6. Stack yellow on top of red\n7. Pick up red\n8. Stack red on top of blue\n9. Pick up blue\n10. Stack blue on top of yellow\n11. Stack blue on top of green\n12. Pick up green\n13. Stack green on top of table\n14. Pick up table\n15. Stack table on top of blue\n16. Pick up blue\n17. Stack blue on top of red\n18. Pick up red\n19. Stack red on top of green\n20. Pick up green\n21. Stack green on top of yellow\n22. Stack green on top of table\n23. Pick up table\n24. Stack table on top of blue\n25. Pick up blue\n26. Stack blue on top of red\n27. Pick up red\n28. Stack red on top of green\n29. Pick up green\n30. Stack green on top of yellow\n31. Stack green on top of table\n32. Pick up table\n33. Stack table on top of blue\n34. Pick up blue\n35. Stack blue on top of red\n36. Pick up red\n37. Stack red on top of green\n38. Pick up green\n39. Stack green on top of yellow\n40. Stack green on top of table\n41. Pick up table\n42. Stack table on top of blue\n43. Pick up blue\n44. Stack blue on top of red\n45. Pick up red\n46. Stack red on top of green\n47. Pick up green\n48. Stack green on top of yellow\n49. Stack green on top of table\n50. Pick up table\n51. Stack table on top of blue\n52. Pick up blue\n53. Stack blue on top of red\n54. Pick up red\n55. Stack red on top of green\n56. Pick up green\n57. Stack green on top of yellow\n58. Stack green on top of table\n59. Pick up table\n60. Stack table on top of"
    },
    {
      "example_id": 49,
      "input": "Rule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<yellow on blue>\n<red>\n\nGoal state:\n<green on blue on yellow on red>",
      "expected": "Plan:\nstep 1: pick-up yellow\nstep 2: stack yellow on-top-of red\nstep 3: pick-up blue\nstep 4: stack blue on-top-of yellow\nstep 5: pick-up green\nstep 6: stack green on-top-of blue",
      "predicted": "<green on blue on yellow on red>\n\nMy solution:\n```\ndef solve(init_state, goal_state, rules):\n    def dfs(state, pos, stack, table):\n        if len(stack) == 0:\n            return\n\n        if pos == 0:\n            return\n\n        if table[pos] == 0:\n            return\n\n        if table[pos] == 1:\n            stack.append(pos)\n            dfs(state, pos - 1, stack, table)\n            stack.pop()\n\n        if table[pos] == 2:\n            stack.append(pos)\n            dfs(state, pos + 1, stack, table)\n            stack.pop()\n\n    def backtrack(state, pos, stack, table):\n        if len(stack) == 0:\n            return\n\n        if pos == 0:\n            return\n\n        if table[pos] == 0:\n            stack.append(pos)\n            dfs(state, pos - 1, stack, table)\n            stack.pop()\n\n        if table[pos] == 1:\n            stack.append(pos)\n            dfs(state, pos + 1, stack, table)\n            stack.pop()\n\n        if table[pos] == 2:\n            stack.append(pos)\n            dfs(state, pos + 2, stack, table)\n            stack.pop()\n\n    return backtrack(init_state, 0, [], [0, 1, 2])\n```\n\n### 21. Given the rules, initial state, and goal state, generate an optimal plan to transform the initial state into the goal state.\n\nRule:\nYou can pick-up color1. You can stack color1 on-top-of color2. You can stack color1 on-top-of table.\n\nInit state:\n<green>\n<yellow on blue>\n<red>\n\nGoal state:\n<green on blue on yellow on red>\n\nPlan:\n<green on blue on yellow on red>\n\nMy solution:\n```\ndef solve(init_state, goal_state, rules):\n    def dfs(state,"
    }
  ]
}